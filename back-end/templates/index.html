<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Accessible Route Finder</title>
</head>
<body>
    <h1>Find Accessible Routes</h1>
    <form id="path-form">
        <label for="start-node">Start:</label>
        <select id="start-node" required>
            <option value="" disabled selected>Select start node</option>
        </select>

        <label for="end-node">End:</label>
        <select id="end-node" required>
            <option value="" disabled selected>Select end node</option>
        </select>

        <button type="submit">Find Path</button>
    </form>

    <h3>Shortest Path:</h3>
    <ul id="path-result"></ul>

    <script>
        let graph = {}; // Store the graph from map.json

        // Load and populate nodes from map.json
        async function loadNodes() {
            try {
                const response = await fetch("map.json"); // Load local file
                const data = await response.json();
                graph = data; // Store for pathfinding

                const startNodeSelect = document.getElementById("start-node");
                const endNodeSelect = document.getElementById("end-node");

                // Populate dropdowns with node names
                Object.keys(graph).forEach(node => {
                    const option1 = new Option(node, node);
                    const option2 = new Option(node, node);
                    startNodeSelect.add(option1);
                    endNodeSelect.add(option2);
                });
            } catch (error) {
                console.error("Error loading nodes:", error);
            }
        }

        // Dijkstra's Algorithm for shortest path
        function findShortestPath(start, end) {
            let distances = {};
            let prev = {};
            let unvisited = new Set(Object.keys(graph));

            // Initialize distances
            for (let node of unvisited) {
                distances[node] = Infinity;
            }
            distances[start] = 0;

            while (unvisited.size > 0) {
                let current = [...unvisited].reduce((minNode, node) =>
                    distances[node] < distances[minNode] ? node : minNode
                );

                unvisited.delete(current);

                if (current === end) {
                    let path = [];
                    while (prev[current]) {
                        path.unshift(current);
                        current = prev[current];
                    }
                    path.unshift(start);
                    return path;
                }

                if (distances[current] === Infinity) break;

                for (let [neighbor, weight] of Object.entries(graph[current])) {
                    let alt = distances[current] + weight;
                    if (alt < distances[neighbor]) {
                        distances[neighbor] = alt;
                        prev[neighbor] = current;
                    }
                }
            }
            return null; // No path found
        }

        // Handle form submission
        document.getElementById("path-form").addEventListener("submit", function(event) {
            event.preventDefault();

            const startNode = document.getElementById("start-node").value;
            const endNode = document.getElementById("end-node").value;
            const resultList = document.getElementById("path-result");
            resultList.innerHTML = "";

            if (startNode && endNode) {
                const path = findShortestPath(startNode, endNode);
                if (path) {
                    path.forEach(node => {
                        const listItem = document.createElement("li");
                        listItem.textContent = node;
                        resultList.appendChild(listItem);
                    });
                } else {
                    resultList.innerHTML = "<li>No path found.</li>";
                }
            }
        });

        // Load nodes on page load
        window.addEventListener("load", loadNodes);
    </script>
</body>
</html>
